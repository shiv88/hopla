RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:41  PAGE  1

QCW(0x0002AE52)

DOS RC51 COMPILER V03.03.37, COMPILATION OF MODULE CFILE     
OBJECT MODULE PLACED IN C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\Compile\CFile.obj
COMPILER INVOKED BY: OJ(C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\Compile\CFile.obj) PIN(c:\RIDE\Inc;C:\DO
            -CUME~1\ib\LOCALS~1\Temp\RemoterTemp\SysPlc\;C:\DOCUME~1\ib\LOCALS~1\Temp\RemoterTemp\Fb\) PR(C:\Documents and Settings\
            -ib\My Documents\RemoterApplications\HOPLA\Compile\List\CFile.lst) LA FP(IEEE,FP251) NOGENERIC NOAM NOEXTEND CD NOINTVEC
            -TOR SB OE(2) IP PL(80) PW(132) MAXWAR(50) IS SIGNEDCHAR 

stmt level    source
   1          /*-----------------------------------------------------------------------------+
   2          |       Copyright (c), 3iP, 2007                                               |
   3          |       File: FSM.c    Finite State Multi-SubMachines                          |
   4          +--------------+-------+----------------------------------------------+--------+
   5          |     DATE     |VERSION| HISTORY/CHANGES                              |   BY   |
   6          |  (MM/DD/YY)  | VX.Y  |                                              |        |
   7          +--------------+-------+----------------------------------------------+--------+
   8          |   12/01/07   | 0.1.1 | Start of implementation.                     |   IB   |
   9          |   15/05/07   | 0.1.2 | Redefinition of AI/DI/DO/AO                  |   IB   |
  10          |    1/06/07   | 0.1.3 | New project structure                        |   IB   |
  11          |    3/07/07   | 0.2.0 | Cuceglio home implementation/ only heating   |   IB   |
  12          |    17/2/08   | 0.2.1 | Cuceglio home implementation/ only heating   |   IB   |
  13          |    19/11/10  | 0.3.0 | Cuceglio home implementation/ only heating   |   IB   |
  14          |              |       | simplified                                   |        |
  15          |    19/11/10  | 0.3.1 | Cuceglio home implementation/ only heating   |   IB   |
  16          |              |       | more simplified                              |        |
  17          |    19/11/10  | 0.4.0 | Cuceglio home implementation/ only heating   |   IB   |
  18          |              |       | simplified  + Serial communication           |        |
  19          |    19/11/10  | 0.4.1 | tolto accesso diretto PLCOPI e PLCRTCHOur e  |   IB   |
  20          |              |       | ripristinato vettore DI esterno statico.     |        |
  21          |              |       | Risolto b2.                                  |        |
  22          |     4/1/11   | 0.5.0 | tolto utilizzo Modbus per debug.             |   IB   |
  23          |              |       | Risolto b1                                   |        |
  24          |     6/2/11   | 0.6.0 | Aggiunto termostato T2, cam Paolo            |   IB   |
  25          |              |       | Aggiunto comando S - Stato totale            |        |
  26          |     25/2/11  | 0.6.1 | Aggiunto termostato T3, soggiorno            |   IB   |
  27          |              |       | ottimizz.switch/case controllo T0/1/2/3      |        | 
  28          |              |       | Aggiunto comando S - Stato totale            |        |
  29          |  26/2/11 wip | 0.7.0 | Aggiunto Misura tempo di accensione          |   IB   |
  30          |              |       | Aggiunta comando leggi tempo di accensione   |        |
  31          |              |       | Ottimizzazione dimensione codice oggetto     |        |
  32          |  27/2/11 wip | 0.7.1 | Aggiunta statistiche giornaliere per un anno |   IB   |
  33          |              |       | Risolto b3                                   |        |
  34          |  6/3/11 run  | 0.7.2 | Nuovo parser                                 |   IB   |
  35          |  16/3/11 wip | 0.8.0 | Retain configuration vector                  |   IB   |
  36          |              |       |                                   |        |
  37          +--------------+-------+----------------------------------------------+-------*/
  38          
  39          //buglist
  40          // 0.4.0: b1 non sempre risponde ai comandi via seriali, alcune volte bisogna ripeterli 3-4 volte prima di avere rispo
            -sta. Risolto in 0.5.0
  41          // 0.4.0: b2 non parte mai la caldaia !!! Risolto in 0.4.1
  42          // 0.7.0: b3 errore calcolo minuti al cambio giorno
  43          // 0.7.0: b4 manca possibilita' di settare il giorno del rtc
  44          
  45          // -----------------------------------------------------------------------------
  46          // FILE INCLUSIONS ANSI-C ed ELSIST
  47          // -----------------------------------------------------------------------------
  48          #include <stdio.h>
  49          #include <string.h>
  50          #include <ctype.h>
  51          #include <ElSystemLib.h>
  52          #include <ElPLCLib.h>
  53          
  54          // -----------------------------------------------------------------------------
  55          // Le define corrispondono alle connessioni su morsettiere
  56          // -----------------------------------------------------------------------------
  57          #define TERMOSTATOP1CORR 0
  58          #define TERMOSTATOP0 1
  59          #define TERMOSTATOP1PAOLO 2
  60          #define TERMOSTATOP1GIORNO 3
  61          #define HEATER_ON 0
  62          #define ZONA1N 4
  63          #define ZONA1G 5
  64          #define ZONA1B 6
  65          #define ZONAP0 7
  66          
  67          
  68          // -----------------------------------------------------------------------------
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  2

  69          // debug. Togliere i commenti dalle define per attivare i debug su COM 
  70          // -----------------------------------------------------------------------------
  71          //#define DBG_LEVEL
  72          #ifdef DBG_LEVEL
                  char dbg1;
                  char dbg2;
              #endif
  76          //#define DBG_PARSECOM
  77          
  78          // -----------------------------------------------------------------------------
  79          // global variable declarations
  80          // -----------------------------------------------------------------------------
  81          
  82          // Max in/out del modulo
  83          #define MAXDI 16
  84          #define MAXDO 8
  85          
  86          BOOL DI[MAXDI]={
  87          0, // TERMOSTATOP1CORR 0
  88          0, // TERMOSTATOP0 1
  89          0, // TERMOSTATOP1PAOLO2  stanza paolo
  90          0, //TEMOSTATOP1GIORNO
  91          0,0,0,0,0,0,0,0,0,0,0,0 };
  92          
  93          BOOL DO[MAXDO]={
  94          0, //HEATER_ON 0
  95          0,0,0,
  96          0, // ZONA1N 4
  97          0, // ZONA1G 5
  98          0, // ZONA1B 6
  99          0 // ZONAP0 7
 100          };
 101          
 102          static int nextaction=0;
 103          int openvalves=0;
 104          RTCDATA RtcData; //Rtc data structure
 105          
 106          // @Section("Custom Function - 0.7.0")  Misura tempo di accensione
 107          RTCDATA RtcPLCSTARTTime,RtcONTime, RtcTimeNow; //Rtc data structure
 108          unsigned int PreviousStatus, TotMinutiON, TotOreON;
 109          // @Section("Custom Function - 0.7.1")  statistiche
 110          unsigned int StatMinutiON[12][31];
 111          
 112          // @Section("Custom Function - 0.7.2")  nuovo parsecom
 113          // -----------------------------------------------------------------------------
 114          // PARSECOM PROTOTYPE
 115          // -----------------------------------------------------------------------------
 116          char ParseCOM2(char *argcnt, char *argvect);
 117          #define CMDLINEMAXLEN 32
 118          // -----------------------------------------------------------------------------
 119          // PARSECOM EXTERN VARIABLES
 120          // -----------------------------------------------------------------------------
 121          static char chptr=0;
 122          static char argcnt;
 123          static char argvect[6];
 124          static char cmdline[32];
 125          struct cmd_descr {
 126              char cmd[10];
 127              char argnum;
 128          } commandlist[]= { {"nop", 0 }, {"status", 0}, {"timeset", 2}, {"timeread",0},
 129              {"dataset", 3},{"dataread",0} , {"reset",0} };
 130          #define NUMCOMANDI 7
 131          
 132          // @Section("8.0.0 - Retain confort vector")
 133          extern unsigned long ZonaNotte;
 134          extern unsigned long ZonaGiorno;
 135          extern unsigned long ZonaBagni;
 136          extern unsigned long P0ZonaUnica;
 137          
 138          // -----------------------------------------------------------------------------
 139          // HEATING ZONES CONFIGURATION
 140          // -----------------------------------------------------------------------------
 141          
 142          
 143          // B=bathroom
 144          // X = all off
 145          // N= zona notte + corridoi + bagni
 146          // G= zona giorno + corridoi + bagni
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  3

 147          // A= All ON\
 148          //                                          22221111111111
 149          //                                          321098765432109876543210          
 150          unsigned long defaultZonaNotte=   0b00000000111100000110000010000000;
 151          unsigned long defaultZonaGiorno=  0b00000000011111111111111110000000;
 152          unsigned long defaultZonaBagni=   0b00000000011111111111111111000000;
 153          unsigned long defaultP0ZonaUnica= 0b00000000111111111111111111111111;
 154          
 155          da fare:

*** ERROR C162 IN LINE 155 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Syntax error near 'fare
            -'
 156          1- comando per caricare default nei vettori confort

*** ERROR C074 IN LINE 156 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Invalid declaration syn
            -tax
 157          2- cambiare la logica di accensione output utilizzando i vettori retain

*** ERROR C056 IN LINE 157 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Syntax error

*** ERROR C074 IN LINE 156 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Invalid declaration syn
            -tax

*** ERROR C074 IN LINE 157 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Invalid declaration syn
            -tax
 158          3- cambiare i comandi di modifica della programm comfort

*** ERROR C056 IN LINE 158 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Syntax error

*** ERROR C074 IN LINE 157 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Invalid declaration syn
            -tax

*** ERROR C074 IN LINE 158 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Invalid declaration syn
            -tax
 159          
 160          char comfortP0[24]={

*** ERROR C056 IN LINE 160 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Syntax error
 161          'A','A','A','A','A','A',
 162          'A','A','A','A','A','A',
 163          'A','A','A','A','A','A',
 164          'A','A','A','A','A','A' }; 
 165          char comfortP1[24]={
 166          'X', // dalle 00:00 alle 00:59 -> tutto spento
 167          'X','X','X','X','X',// dalle 1:00 alle 5:59 -> tutto spento 
 168          'B', // dalle 6:00 alle 6:59 -> zona bagni
 169          'A', // dalle 7:00 alle 7:59 -> tutto acceso 
 170          'G','G','G','G','G', // dalle 8:00 alle 12:59 -> Bagni + Zona Giorno + Corridoi
 171          'A','A', // tutto acceso dalle 13:00 alle 14:59
 172          'G','G','G','G','G', // dalle 15:00 alle 19:59 -> Bagni + Zona Giorno 
 173          'A','A','A',// dalle 20:00 alle 22:59 -> tutto acceso
 174          'N' }; // dalle 23:00 alle 23:59 -> zona notte+corridoi+bagni 
 175          
 176          
 177          // function prototipes
 178          //void   ManageHeatingInputs(void);
 179          void   ManageHeatingOutputs(void);         
 180          
 181          char ExecuteCmd(unsigned char , unsigned char );
 182          // -----------------------------------------------------------------------------
 183          // CUSTOM FUNCTION
 184          // -----------------------------------------------------------------------------
 185          
 186          // @Section("Custom Function - C Entry point")
 187          void CustomFunction(void)
 188          {
 189   1      SERIALSTRUCT SerialStruct; //Serial parameters
 190   1      int i,j;
 191   1      
 192   1          if (PLCFirstLoop)
 193   1          {
 194   2      
 195   2       // Enable the serial communication on serial port "" and define parameters.
 196   2       // Set serial at 19200, e, 8. DTR automatically managed without any time
 197   2              SetTermIOVectors(IOSerialPortA); //Set the serial port A as I/O console
 198   2              GetSerialMode(&SerialStruct); //Get communication mode
 199   2              SerialStruct.Mode.DTRComplement=FALSE; //Complement the DTR signal
 200   2              SerialStruct.Mode.EchoFlush=FALSE; //Flush the echo
 201   2              SerialStruct.Mode.RxCtrlDisable=TRUE; //Disable Rx control characters
 202   2              SerialStruct.Mode.DTRManagement=2; //Define the DTR management
 203   2              SerialStruct.Mode.WaitLoop=FALSE; //FALSE:No wait, TRUE:Wait
 204   2              SerialStruct.Mode.ParityEnabled=TRUE; //Enables the parity management
 205   2              SerialStruct.Mode.ParityType=TRUE; //FALSE:Odd parity, TRUE:Even parity
 206   2              SerialStruct.Mode.BitNumber=TRUE; //FALSE:7 bit, TRUE:8 bit
 207   2              SerialStruct.Mode.WaitLoop=FALSE; //FALSE:No wait, TRUE:Wait
 208   2              SerialStruct.Mode.Baud=6; //Baud rate
 209   2              SerialStruct.DTROnTime=0; //DTR On wait time
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  4

 210   2              SerialStruct.DTROffTime=0; //DTR Off delay time
 211   2              SetSerialMode(&SerialStruct); //Set communication mode
 212   2      
 213   2              // @Section("Custom Function - 0.7.0")  misura tempo di accensione
 214   2              PreviousStatus = 0;
 215   2              TotMinutiON=TotOreON=0;
 216   2              GetRtc (&RtcPLCSTARTTime);
 217   2             // @Section("Custom Function - 0.7.1")  statistiche
 218   2              for (i=0;i<12;i++)
 219   2                  for (j=0;j<31;j++)
 220   2                      StatMinutiON[i][j]=0; 
 221   2      
 222   2      #ifdef DBG_LEVEL
       2              printf("first loop/n");
       2              dbg1 = 1; //1 ==> first loop
       2              dbg2 = 1; 
       2      #endif
 227   2          }
 228   1      
 229   1          //cambiato il 20/11/2010 mattina
 230   1          DI[TERMOSTATOP0] = PLCOpI(TERMOSTATOP0);
 231   1      	DI[TERMOSTATOP1CORR] = PLCOpI(TERMOSTATOP1CORR);           
 232   1      	DI[TERMOSTATOP1PAOLO] = PLCOpI(TERMOSTATOP1PAOLO);           
 233   1      	DI[TERMOSTATOP1GIORNO] = PLCOpI(TERMOSTATOP1GIORNO);
 234   1           	
 235   1          // input/outpout via seriale
 236   1          if ((i=ParseCOM2(&argcnt, argvect))>0)
 237   1          {
 238   2      #ifdef DBG_PARSECOM
       2              printf ("funziona:%d\n",i);
       2      #endif
 241   2              if (i==1)
 242   2                  ExecuteCmd('S', 0);
 243   2              if (i==3)
 244   2                  ExecuteCmd('T', 0);
 245   2      
 246   2              if (i==2)
 247   2              {
 248   3                  ExecuteCmd('H', argvect[0]);
 249   3                  ExecuteCmd('m', argvect[1]);
 250   3              }
 251   2      
 252   2              if (i==4)
 253   2              {
 254   3                  ExecuteCmd('d', argvect[0]);
 255   3                  ExecuteCmd('M', argvect[1]);
 256   3                  ExecuteCmd('Y', argvect[2]);
 257   3              }
 258   2               if (i==6)
 259   2              {
 260   3                  ZonaNotte = defaultZonaNotte;   
 261   3                  Zona Giorno = defaultZonaGiorno;

*** ERROR C014 IN LINE 261 OF C:\Documents and Settings\ib\My Documents\RemoterApplications\HOPLA\CFile.c : Undefined 'Zona'
 262   3                  ZonaBagni =defaultZonaBagni;
 263   3                  P0ZonaUnica = defaultP0ZonaUnica;
 264   3              }
 265   2          }
 266   1          // Gestione sequenziale degli Input e degli Output e della seriale, con periodo di un secondo
 267   1          if (PLCPulse1000)
 268   1          {
 269   2              if (nextaction==2)
 270   2                  nextaction=0;
 271   2      
 272   2              switch (nextaction)
 273   2              {
 274   3                  case 0:
 275   3                      ;
 276   3                      break;
 277   3      
 278   3                  case 1:
 279   3                      ManageHeatingOutputs();
 280   3                      break;
 281   3      
 282   3      	        case 2:
 283   3                      ;
 284   3      		        break;
 285   3      
 286   3                  default:
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  5

 287   3                      return;
 288   3              }
 289   2              nextaction++;
 290   2          } 
 291   1      }
 292          
 293          
 294          // @Section("Custom Function - 0.7.2")  nuovo parsecom
 295          // ritorna il numero del comando, sempre >0, in caso di successo
 296          // ritorna 0 no operation (ad esempio sta leggendo la riga)
 297          // ritorna <0 per errori
 298          char ParseCOM2(char *argcnt, char *argvect)
 299          {
 300   1      
 301   1      char *p;
 302   1      char c, i, retcmd;
 303   1      
 304   1      // Manage the serial port "A" tick.
 305   1          SetTermIOVectors(IOSerialPortA); //Set the serial port A as I/O console
 306   1          TermIOTick(); //Manage the selected I/O console
 307   1      
 308   1         if (GetRxChars())
 309   1          {
 310   2      
 311   2              // Read the received character.
 312   2              c=GetCh();
 313   2              if ( (isalnum(c) || isspace(c) || (c == ':')) && (c!= 13) ) 
 314   2              {
 315   3                  cmdline[chptr]=c;
 316   3                  chptr++;
 317   3      #ifdef DBG_PARSECOM
       3      printf("c:%d cmdline[]:%c chptr:%d\n",c, cmdline[chptr-1],chptr);
       3      #endif 
 320   3                  if (chptr==CMDLINEMAXLEN) //overflow
 321   3                  {
 322   4                      chptr=0;
 323   4                      cmdline[0]='\0';
 324   4      #ifdef DBG_PARSECOM
       4                      printf("Error 1- cmdline overflow\n");
       4      #endif            
 327   4                      return (-1);
 328   4                  }
 329   3              }    
 330   2              else if (c==13) //enter fine della riga di comando
 331   2              {
 332   3                  cmdline[chptr]='\0';
 333   3                  chptr=0;
 334   3                  printf("\ncmdline=%s\n",cmdline);
 335   3      
 336   3                  for (retcmd=0;retcmd<6;retcmd++)
 337   3                  	if ( (strstr(cmdline,commandlist[retcmd].cmd)) )
 338   3                      		break; //trovato il comando 
 339   3      	        	
 340   3                  if (retcmd== NUMCOMANDI) // non ho trovato comandi
 341   3                      return (-16);
 342   3      
 343   3                  p=cmdline+strlen(commandlist[retcmd].cmd);
 344   3      
 345   3                  for (i=0; i<commandlist[retcmd].argnum; i++)
 346   3                  {
 347   4          		//errore mi attendo un separatore
 348   4          		if ( ((*p)!=' ') && ((*p) != ':') )
 349   4          			return (-retcmd-16*1);
 350   4                 
 351   4          		//skip all white spaces
 352   4          		while (isspace(*p) || ((*p)==':'))
 353   4          			p++; 
 354   4      
 355   4      		//errore string terminata prima di aver letto tutti i parametri
 356   4          		if ((*p)== '\0') 
 357   4          			return (-retcmd-16*2);
 358   4      
 359   4          		//convert all digits
 360   4                  	argvect[i]=0;
 361   4          		while (isdigit(*p))
 362   4                          	argvect[i] = argvect[i]*10 + (*(p++))-'0';          
 363   4      	    }    
 364   3      
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  6

 365   3          	// return parameter
 366   3          	*argcnt=commandlist[retcmd].argnum;
 367   3          	return (retcmd);
 368   3              }
 369   2          }
 370   1          return (0);
 371   1      }
 372          
 373          char ExecuteCmd(unsigned char cmd, unsigned char parm1)
 374          {
 375   1      char i;
 376   1      //  printf ("inside ExcuteCMD. cmd=%u parm1=%u", cmd, parm1);
 377   1        
 378   1          // Manage the serial port tick.
 379   1          SetTermIOVectors(IOSerialPortA); //Set the serial port A as I/O console
 380   1          TermIOTick(); //Manage the selected I/O console
 381   1      
 382   1          GetRtc(&RtcData); //Read the current RTC registers
 383   1      
 384   1          switch (cmd)
 385   1          {
 386   2              case 'H': //impostazione ora. Operando 2chr: hh
 387   2              if (parm1>23)
 388   2                  return (-1); 
 389   2              RtcData.Hour = parm1;
 390   2              SetRtc(&RtcData); //Write the RTC registers with the new values
 391   2              break; 
 392   2      
 393   2              case 'm': //impostazione minuti. Operando 2chr: mm 
 394   2              if (parm1>59) 
 395   2                  return (-1);
 396   2              RtcData.Minute = parm1;
 397   2              SetRtc(&RtcData); //Write the RTC registers with the new values
 398   2              break;
 399   2      
 400   2              case 'd': //impostazione giorno. Operando 2chr: gg
 401   2              if (parm1>31)
 402   2                  return (-1);     
 403   2              RtcData.Day = parm1;
 404   2              SetRtc(&RtcData); //Write the RTC registers with the new values
 405   2              break;
 406   2      
 407   2              case 'M': //impostazione mese. Operando 2chr: MM
 408   2              if ((parm1>0) && (parm1<13)) 
 409   2              {
 410   3                      RtcData.Month = parm1;
 411   3                      SetRtc(&RtcData); //Write the RTC registers with the new values
 412   3                  break;
 413   3              }
 414   2              return (-1);
 415   2      
 416   2              case 'Y': //impostazione anno. Operando 2chr: YY
 417   2              if (parm1>99)
 418   2                  return (-1);     
 419   2              RtcData.Year = parm1;
 420   2              SetRtc(&RtcData); //Write the RTC registers with the new values
 421   2              break;
 422   2      
 423   2          	case 'C': //leggi vettore confort Piano 1. Operando 2chr: 00-23
 424   2              if (parm1>23) 
 425   2              {
 426   3                  printf ( "errore input ora > 23. Inserire 2 cifre dopo il comando C. Es C21\n");
 427   3                  return (-1);
 428   3              }
 429   2              printf ( "piano 1 dalle %u:00 alle %u:59 %c\n", parm1, parm1, comfortP1[parm1]);
 430   2              break;
 431   2               
 432   2              case 'D': //leggi vettore confort Piano 0. Operando 2chr: 00-23
 433   2              if (parm1>23) 
 434   2              {
 435   3                  printf ( "errore input ora > 23. Inserire 2 cifre dopo il comando D. Es D19\n");
 436   3                  return (-1);
 437   3              }
 438   2              printf ( "piano 0 dalle %u:00 alle %u:59 %c\n", parm1, parm1, comfortP0[parm1]);
 439   2              break;
 440   2      
 441   2      	    case 'I': //leggi input  x (00-15)
 442   2              if (parm1>15) 
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  7

 443   2              {
 444   3                  printf ( "errore input > 15. Inserire 2 cifre dopo il comando I. Es I01\n");
 445   3                  return (-1);
 446   3              }
 447   2      
 448   2              printf ( "input %u: %u\n", parm1, DI[parm1] );
 449   2              break;
 450   2      
 451   2      	 case 'O': //leggi output x (00-07)
 452   2              if (parm1>7)
 453   2              {
 454   3                  printf ( "errore input > 7. Inserire 2 cifre dopo il comando O. Es O06\n");
 455   3                  return (-1);
 456   3              }
 457   2              printf ( "output %u: %u\n", parm1, PLCOpO(parm1) );
 458   2              break;
 459   2      
 460   2      	    case 'S': //leggi stato
 461   2              // @Section("Custom Function - 0.7.0") - riduzione object code usando cicli for
 462   2              // 24 byte comfort vector piano 0
 463   2              for (i=0;i<24;i++) printf ( "%c", comfortP0[i]);
 464   2              for (i=0;i<24;i++) printf ( "%c", comfortP1[i]);
 465   2      
 466   2              // 16 byte input
 467   2              for (i=0;i<16;i++) printf ( "%u", DI[i]);
 468   2      
 469   2              // 8 byte output
 470   2              printf ( "%u%u%u%u", PLCOpO(0), PLCOpO(1), PLCOpO(2), PLCOpO(3) );
 471   2              printf ( "%u%u%u%u", PLCOpO(4), PLCOpO(5), PLCOpO(6), PLCOpO(7) );
 472   2       
 473   2              // misura tempo di accensione
 474   2              // @Section("Custom Function - 0.7.0") leggi tempo di accensione
 475   2              printf ( "\nPLC ON FROM: %u %u %u - %u:%u ", RtcPLCSTARTTime.Day, RtcPLCSTARTTime.Month, RtcPLCSTARTTime.Year,
            - RtcPLCSTARTTime.Hour, RtcPLCSTARTTime.Minute );
 476   2              printf ( "\nLAST CALDAIA ON: %u %u %u - %u:%u ", RtcONTime.Day, RtcONTime.Month, RtcONTime.Year, RtcONTime.Hou
            -r, RtcONTime.Minute );
 477   2              printf ( "\nCALDAIA ON FROM%u", TotMinutiON);
 478   2          
 479   2              printf ( "\n");
 480   2       
 481   2              break;
 482   2      
 483   2      	    case 'T': //leggi real time clock
 484   2              printf ( "real time clock: %u %u %u - %u:%u:%u\n ", RtcData.Day, RtcData.Month, RtcData.Year, RtcData.Hour, Rt
            -cData.Minute, RtcData.Second );
 485   2              break;
 486   2      
 487   2      //configurazine vettore comfort piano 1
 488   2              case 'X': //imposta tutto spento alle ore hh. Operando 2chr: hh
 489   2          	case 'A': //imposta tutto acceso alle ore hh. Operando 2chr: hh
 490   2      	    case 'G': //imposta zona giorno accesa alle ore hh. Operando 2chr: hh
 491   2      	    case 'N': //imposta zona notte accesa alle ore hh. Operando 2chr: hh
 492   2      	    case 'B': //imposta zona notte accesa alle ore hh. Operando 2chr: hh
 493   2      	    if (parm1>23) 
 494   2              {
 495   3                  printf ( "errore input ora > 23. Inserire 2 cifre dopo il comando %c. Es %c19\n",cmd,cmd);
 496   3                  return (-1);
 497   3              }
 498   2                  comfortP1[parm1]=cmd;
 499   2                  printf ( "piano 1 impostato ad %c dalle %u:00 alle %u:59\n", comfortP1[parm1],parm1, parm1);
 500   2                  break;
 501   2      
 502   2      //configurazine vettore comfort piano 0
 503   2                  case 'x': //imposta tutto spento alle ore hh. Operando 2chr: hh
 504   2          	    case 'a': //imposta tutto acceso alle ore hh. Operando 2chr: hh
 505   2      	        case 'g': //imposta zona giorno accesa alle ore hh. Operando 2chr: hh
 506   2      	        case 'n': //imposta zona notte accesa alle ore hh. Operando 2chr: hh
 507   2                  case 'b': //imposta zona notte accesa alle ore hh. Operando 2chr: hh
 508   2                  if (parm1>23) 
 509   2                  {
 510   3                      printf ( "errore input ora > 23. Inserire 2 cifre dopo il comando %c. Es %c19\n",cmd,cmd);
 511   3                      return (-1);
 512   3                  }
 513   2                  comfortP0[parm1]=cmd+'X'-'x';
 514   2                  printf ( "piano 0 impostato ad %c dalle %u:00 alle %u:59\n", comfortP0[parm1],parm1, parm1);
 515   2                  break;
 516   2          }
 517   1      	return (0);
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  8

 518   1      }
 519          
 520          void   ManageHeatingOutputs(void)
 521          {
 522   1      
 523   1          GetRtc(&RtcData); //Read the current RTC registers
 524   1      
 525   1          DO[ZONA1B]= FALSE ; // zona bagni e corridoio 
 526   1          DO[ZONA1G]= FALSE;
 527   1          DO[ZONA1N]= FALSE;
 528   1          DO[ZONAP0]= FALSE ; // unica zona al piano 0   
 529   1          openvalves = 0;     
 530   1      
 531   1          // First level heating zones corridoio
 532   1          if (DI[TERMOSTATOP1CORR])
 533   1          {
 534   2      //        switch(comfortP1[PLCRtcHour])
 535   2                switch(comfortP1[RtcData.Hour])
 536   2              {
 537   3              case 'A':
 538   3              case 'N':
 539   3              case 'G':
 540   3              case 'B':
 541   3                  DO[ZONA1B] = TRUE ; // zona bagni e corridoio sempre on
 542   3                  openvalves++;
 543   3                  break;
 544   3            
 545   3              case 'X':
 546   3              default:
 547   3                  DO[ZONA1B] = FALSE ; // tutto spento
 548   3                  break;
 549   3              }
 550   2          }
 551   1      
 552   1          // First level heating zones Paolo
 553   1          // @Section("Custom Function - 0.6.0")
 554   1          // @Section("Custom Function - 0.6.1")
 555   1          if (DI[TERMOSTATOP1PAOLO])
 556   1          {
 557   2      //        switch(comfortP1[PLCRtcHour])
 558   2                switch(comfortP1[RtcData.Hour])
 559   2              {
 560   3              case 'A':
 561   3              case 'N':
 562   3                  DO[ZONA1N] =TRUE;
 563   3                  openvalves++;
 564   3                  break;
 565   3              case 'G':
 566   3              case 'B':
 567   3              case 'X':
 568   3              default:
 569   3                  DO[ZONA1N] =FALSE;
 570   3                  break;
 571   3              }
 572   2          }
 573   1      
 574   1         // 0.6.1: First level heating zones SOGGIORNO
 575   1         // @Section("Custom Function - 0.6.1")
 576   1          if (DI[TERMOSTATOP1GIORNO])
 577   1          {
 578   2      //        switch(comfortP1[PLCRtcHour])
 579   2                switch(comfortP1[RtcData.Hour])
 580   2              {
 581   3              case 'A':
 582   3              case 'G':
 583   3                  DO[ZONA1G] =TRUE;
 584   3                  openvalves++;
 585   3                  break;
 586   3              case 'N':
 587   3              case 'B':
 588   3              case 'X':
 589   3              default:
 590   3                  DO[ZONA1G] =FALSE;
 591   3                  break;
 592   3              }
 593   2          }
 594   1      
 595   1          // Level zero heating zone
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE  9

 596   1          if (DI[TERMOSTATOP0])
 597   1          {
 598   2              switch(comfortP0[RtcData.Hour])
 599   2              {
 600   3              case 'A':
 601   3              case 'N':
 602   3              case 'G':
 603   3              case 'B':
 604   3                  DO[ZONAP0]= TRUE ; // unica zona al piano 0
 605   3                  openvalves++;
 606   3                  break;
 607   3      
 608   3              default:
 609   3                  DO[ZONAP0] = FALSE ; // unica zona al piano 0
 610   3                  break;
 611   3              }
 612   2          }
 613   1      
 614   1      // Open/Close VALVES
 615   1          PLCOpO(ZONA1B)= DO[ZONA1B];
 616   1          PLCOpO(ZONA1G)= DO[ZONA1G];
 617   1          PLCOpO(ZONA1N)= DO[ZONA1N];
 618   1          PLCOpO(ZONAP0)= DO[ZONAP0];
 619   1      
 620   1      
 621   1      // Switch on heater only if at last a zone need heating
 622   1          if  ( (DI[TERMOSTATOP0] || DI[TERMOSTATOP1CORR] || DI[TERMOSTATOP1PAOLO]|| DI[TERMOSTATOP1GIORNO]) && openvalves )
            - 
 623   1      	    PLCOpO(HEATER_ON)= TRUE; 
 624   1          else 
 625   1      	    PLCOpO(HEATER_ON)= FALSE; 
 626   1      
 627   1          
 628   1      // 0.7.0 Antiicing management, upgrade per azionare rolling tutte le valvole
 629   1      // LASCIO SEMPRE ALMENO UNA VALVOLA APERTA PER PERMETTERE IL DEICING, GESTITO DALLA CALDAIA
 630   1      // @Section("Custom Function - 0.7.0")
 631   1          if (!openvalves) 
 632   1          {
 633   2              switch(RtcData.Hour%3)
 634   2              {   
 635   3      	    case 0: PLCOpO(ZONA1B)= TRUE ; // zona bagni e corridoio P1    
 636   3                      break;
 637   3              case 1: PLCOpO(ZONAP0)= TRUE ; // unica zona al piano 0
 638   3                      break;
 639   3              case 2: PLCOpO(ZONA1G)= TRUE ; //  zona giorno P1
 640   3                      break;
 641   3              case 3: PLCOpO(ZONA1N)= TRUE ; //  zona notte P1
 642   3                      break;
 643   3              }
 644   2          }
 645   1      
 646   1      
 647   1      // gestisco accensine/spegnimento a cavallo di 2 giorni
 648   1      // @Section("Custom Function - 0.7.1")  statistiche
 649   1              if (RtcData.Day>RtcONTime.Day) // cambiato giorno in questo ciclo
 650   1              {
 651   2                  TotMinutiON +=  
 652   2                    ((24 *60 + 60)
 653   2                    -(RtcONTime.Hour  *60 + RtcONTime.Minute  ));
 654   2      
 655   2                  StatMinutiON[RtcONTime.Month-1][RtcONTime.Day-1]=TotMinutiON;
 656   2                  TotMinutiON=0;
 657   2                  GetRtc (&RtcONTime);
 658   2              }
 659   1      
 660   1      // misura tempo di accensione
 661   1      // @Section("Custom Function - 0.7.0")
 662   1          if (openvalves && !PreviousStatus) //si e' acceso adesso
 663   1          {
 664   2              GetRtc (&RtcONTime);
 665   2              PreviousStatus = TRUE;
 666   2       //       if (PLCOpO(ZONA1N)) PreviousStatus = K_ZONA1N;
 667   2       //       if (PLCOpO(ZONA1G)) PreviousStatus += K_ZONA1G;
 668   2       //       if (PLCOpO(ZONA1B)) PreviousStatus += K_ZONA1B;
 669   2       //       if (PLCOpO(ZONAP0)) PreviousStatus += K_ZONAP0;
 670   2      
 671   2          }
 672   1          else if (!openvalves && PreviousStatus) //si e' spento adesso
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE 10

 673   1          {
 674   2              // GetRtc (&RtcTimeNow);
 675   2       
 676   2              TotMinutiON +=  
 677   2                   (RtcData.Hour *60 + RtcData.Minute )
 678   2                  -(RtcONTime.Hour  *60 + RtcONTime.Minute  ); 
 679   2          
 680   2      //    TotOreON = TotOreON+ (unsigned int)(TotMinutiON/60);
 681   2      //    TotMinutiON=(unsigned int)(TotMinutiON%60);
 682   2              PreviousStatus=FALSE;
 683   2      }
 684   1      //        TotTermoON += PreviousStatus;
 685   1      
 686   1      }
 687          
 688          
 689          
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE 11

ASSEMBLY LISTING OF GENERATED OBJECT CODE

RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE 12

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====

DI . . . . . . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   0000H   16   
DO . . . . . . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   0010H   8    
nextaction . . . . . . . . . . . . . .  STATIC  XDATA   INT     0018H   2    
openvalves . . . . . . . . . . . . . .  PUBLIC  XDATA   INT     001AH   2    
RtcData. . . . . . . . . . . . . . . .  PUBLIC  XDATA   STRUCT  001CH   8    
RtcPLCSTARTTime. . . . . . . . . . . .  PUBLIC  XDATA   STRUCT  0024H   8    
RtcONTime. . . . . . . . . . . . . . .  PUBLIC  XDATA   STRUCT  002CH   8    
RtcTimeNow . . . . . . . . . . . . . .  PUBLIC  XDATA   STRUCT  0034H   8    
PreviousStatus . . . . . . . . . . . .  PUBLIC  XDATA   U_INT  003CH   2    
TotMinutiON. . . . . . . . . . . . . .  PUBLIC  XDATA   U_INT  003EH   2    
TotOreON . . . . . . . . . . . . . . .  PUBLIC  XDATA   U_INT  0040H   2    
StatMinutiON . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   0042H   744  
chptr. . . . . . . . . . . . . . . . .  STATIC  XDATA   CHAR    032AH   1    
argcnt . . . . . . . . . . . . . . . .  STATIC  XDATA   CHAR    032BH   1    
argvect. . . . . . . . . . . . . . . .  STATIC  XDATA   ARRAY   032CH   6    
cmdline. . . . . . . . . . . . . . . .  STATIC  XDATA   ARRAY   0332H   32   
cmd_descr. . . . . . . . . . . . . . .  * TAG * -----   STRUCT  -----   11   
  cmd. . . . . . . . . . . . . . . . .  MEMBER  -----   ARRAY   0000H   10   
  argnum . . . . . . . . . . . . . . .  MEMBER  -----   CHAR    000AH   1    
commandlist. . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   0352H   77   
defaultZonaNotte . . . . . . . . . . .  PUBLIC  XDATA   U_LONG  039FH   4    
defaultZonaGiorno. . . . . . . . . . .  PUBLIC  XDATA   U_LONG  03A3H   4    
defaultZonaBagni . . . . . . . . . . .  PUBLIC  XDATA   U_LONG  03A7H   4    
defaultP0ZonaUnica . . . . . . . . . .  PUBLIC  XDATA   U_LONG  03ABH   4    
comfortP0. . . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   03AFH   24   
comfortP1. . . . . . . . . . . . . . .  PUBLIC  XDATA   ARRAY   03C7H   24   
PLCFirstLoop . . . . . . . . . . . . .  EXTERN  XDATA   U_CHAR  -----   -----
IOSerialPortA. . . . . . . . . . . . .  EXTERN  XDATA   PTR     -----   -----
PLCMemoryLogicInputs . . . . . . . . .  EXTERN  XDATA   ARRAY   -----   -----
ZonaNotte. . . . . . . . . . . . . . .  EXTERN  XDATA   U_LONG  -----   -----
ZonaBagni. . . . . . . . . . . . . . .  EXTERN  XDATA   U_LONG  -----   -----
P0ZonaUnica. . . . . . . . . . . . . .  EXTERN  XDATA   U_LONG  -----   -----
PLCPulse1000 . . . . . . . . . . . . .  EXTERN  XDATA   U_CHAR  -----   -----
PLCMemoryLogicOutputs. . . . . . . . .  EXTERN  XDATA   ARRAY   -----   -----
RC51 COMPILER V03.03.37,  CFILE                  03/17/11  19:16:42  PAGE 13



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =    679    ----
   XDATA SIZE       =    991    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

RC51 COMPILATION COMPLETE.  0 WARNING, 10 ERRORS
